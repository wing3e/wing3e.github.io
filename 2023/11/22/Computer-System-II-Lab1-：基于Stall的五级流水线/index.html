<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Computer System II Lab1 ：基于Stall的五级流水线 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  <meta name="description" content="1 实验目的 2 实验原理：将上学期写过的单周期CPU改为流水线CPU，并实现5级stall。通过IF，ID，EXE，MEM，WB，五个阶段分别完成对应的任务，实现指令的执行并与此同时大大提高CPU的运行速率。  3 实验步骤3-1 SCPU to PipeLine由上述原理图可以看到，我们在SCPU中使用的许多模块在PipeLine中仍然需要用到，且这些模块的内部结构并未发生很大变化。 所以为将">
<meta property="og:type" content="article">
<meta property="og:title" content="Computer System II Lab1 ：基于Stall的五级流水线">
<meta property="og:url" content="http://47.96.29.144/2023/11/22/Computer-System-II-Lab1-%EF%BC%9A%E5%9F%BA%E4%BA%8EStall%E7%9A%84%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1 实验目的 2 实验原理：将上学期写过的单周期CPU改为流水线CPU，并实现5级stall。通过IF，ID，EXE，MEM，WB，五个阶段分别完成对应的任务，实现指令的执行并与此同时大大提高CPU的运行速率。  3 实验步骤3-1 SCPU to PipeLine由上述原理图可以看到，我们在SCPU中使用的许多模块在PipeLine中仍然需要用到，且这些模块的内部结构并未发生很大变化。 所以为将">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://47.96.29.144/2023/11/22/Computer-System-II-Lab1-%EF%BC%9A%E5%9F%BA%E4%BA%8EStall%E7%9A%84%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF/1.png">
<meta property="og:image" content="http://47.96.29.144/2023/11/22/Computer-System-II-Lab1-%EF%BC%9A%E5%9F%BA%E4%BA%8EStall%E7%9A%84%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF/2.png">
<meta property="og:image" content="http://47.96.29.144/2023/11/22/Computer-System-II-Lab1-%EF%BC%9A%E5%9F%BA%E4%BA%8EStall%E7%9A%84%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF/3.png">
<meta property="og:image" content="http://47.96.29.144/2023/11/22/Computer-System-II-Lab1-%EF%BC%9A%E5%9F%BA%E4%BA%8EStall%E7%9A%84%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF/4.png">
<meta property="og:image" content="http://47.96.29.144/2023/11/22/Computer-System-II-Lab1-%EF%BC%9A%E5%9F%BA%E4%BA%8EStall%E7%9A%84%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF/5.png">
<meta property="og:image" content="http://47.96.29.144/2023/11/22/Computer-System-II-Lab1-%EF%BC%9A%E5%9F%BA%E4%BA%8EStall%E7%9A%84%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF/6.png">
<meta property="og:image" content="http://47.96.29.144/2023/11/22/Computer-System-II-Lab1-%EF%BC%9A%E5%9F%BA%E4%BA%8EStall%E7%9A%84%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF/7.jpg">
<meta property="og:image" content="http://47.96.29.144/2023/11/22/Computer-System-II-Lab1-%EF%BC%9A%E5%9F%BA%E4%BA%8EStall%E7%9A%84%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF/6.png">
<meta property="og:image" content="http://47.96.29.144/2023/11/22/Computer-System-II-Lab1-%EF%BC%9A%E5%9F%BA%E4%BA%8EStall%E7%9A%84%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF/9.png">
<meta property="og:image" content="http://47.96.29.144/2023/11/22/Computer-System-II-Lab1-%EF%BC%9A%E5%9F%BA%E4%BA%8EStall%E7%9A%84%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF/10.png">
<meta property="og:image" content="http://47.96.29.144/2023/11/22/Computer-System-II-Lab1-%EF%BC%9A%E5%9F%BA%E4%BA%8EStall%E7%9A%84%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF/11.png">
<meta property="og:image" content="http://47.96.29.144/2023/11/22/Computer-System-II-Lab1-%EF%BC%9A%E5%9F%BA%E4%BA%8EStall%E7%9A%84%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF/12.png">
<meta property="og:image" content="http://47.96.29.144/2023/11/22/Computer-System-II-Lab1-%EF%BC%9A%E5%9F%BA%E4%BA%8EStall%E7%9A%84%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF/13.png">
<meta property="og:image" content="http://47.96.29.144/2023/11/22/Computer-System-II-Lab1-%EF%BC%9A%E5%9F%BA%E4%BA%8EStall%E7%9A%84%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF/14.png">
<meta property="og:image" content="http://47.96.29.144/2023/11/22/Computer-System-II-Lab1-%EF%BC%9A%E5%9F%BA%E4%BA%8EStall%E7%9A%84%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF/15.png">
<meta property="og:image" content="http://47.96.29.144/2023/11/22/Computer-System-II-Lab1-%EF%BC%9A%E5%9F%BA%E4%BA%8EStall%E7%9A%84%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF/16.png">
<meta property="og:image" content="http://47.96.29.144/2023/11/22/Computer-System-II-Lab1-%EF%BC%9A%E5%9F%BA%E4%BA%8EStall%E7%9A%84%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF/17.png">
<meta property="og:image" content="http://47.96.29.144/2023/11/22/Computer-System-II-Lab1-%EF%BC%9A%E5%9F%BA%E4%BA%8EStall%E7%9A%84%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF/18.png">
<meta property="og:image" content="http://47.96.29.144/2023/11/22/Computer-System-II-Lab1-%EF%BC%9A%E5%9F%BA%E4%BA%8EStall%E7%9A%84%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF/19.png">
<meta property="og:image" content="http://47.96.29.144/2023/11/22/Computer-System-II-Lab1-%EF%BC%9A%E5%9F%BA%E4%BA%8EStall%E7%9A%84%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF/20.png">
<meta property="og:image" content="http://47.96.29.144/2023/11/22/Computer-System-II-Lab1-%EF%BC%9A%E5%9F%BA%E4%BA%8EStall%E7%9A%84%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF/21.png">
<meta property="article:published_time" content="2023-11-22T09:42:08.000Z">
<meta property="article:modified_time" content="2023-11-22T09:47:08.167Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://47.96.29.144/2023/11/22/Computer-System-II-Lab1-%EF%BC%9A%E5%9F%BA%E4%BA%8EStall%E7%9A%84%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF/1.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/images/avatar.jpg">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/css/highlight.css">

<meta name="generator" content="Hexo 7.0.0"></head>

<body>
  <div id="fullpage" class="mobile-nav-right">
    
      <div id="wrapper" title="图片来自网络">
    
    
      <header id="header">
  <div id="nav-toggle" class="nav-toggle"></div>
  <div class="head-box global-width">
    <nav class="nav-box nav-right">
      
        <a class="nav-item" href="/" title
        
        >首页</a>
      
        <a class="nav-item" href="/archives" title
        
        >归档</a>
      
        <a class="nav-item" href="/PWN" title
        
        >Pwn</a>
      
    </nav>
  </div>
</header>
      <div id="middlecontent" title class="global-width sidebar-right">
        <section id="main"><article id="post-Computer-System-II-Lab1-：基于Stall的五级流水线" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 class="article-title" itemprop="name">
      Computer System II Lab1 ：基于Stall的五级流水线
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2023/11/22/Computer-System-II-Lab1-%EF%BC%9A%E5%9F%BA%E4%BA%8EStall%E7%9A%84%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF/" class="article-date">
  <time datetime="2023-11-22T09:42:08.000Z" itemprop="datePublished">2023-11-22</time>
</a>
    
    
  </div>
  
    <span id="busuanzi_container_page_pv">
      本文总阅读量<span id="busuanzi_value_page_pv"></span>次
    </span>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <h2 id="1-实验目的"><a href="#1-实验目的" class="headerlink" title="1 实验目的"></a>1 实验目的</h2><p><img src="/2023/11/22/Computer-System-II-Lab1-%EF%BC%9A%E5%9F%BA%E4%BA%8EStall%E7%9A%84%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF/1.png" alt="1"></p>
<h2 id="2-实验原理："><a href="#2-实验原理：" class="headerlink" title="2 实验原理："></a>2 实验原理：</h2><p>将上学期写过的单周期CPU改为流水线CPU，并实现5级stall。通过IF，ID，EXE，MEM，WB，五个阶段分别完成对应的任务，实现指令的执行并与此同时<strong>大大提高CPU的运行速率。</strong></p>
<p><img src="/2023/11/22/Computer-System-II-Lab1-%EF%BC%9A%E5%9F%BA%E4%BA%8EStall%E7%9A%84%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF/2.png" alt="2"></p>
<h2 id="3-实验步骤"><a href="#3-实验步骤" class="headerlink" title="3 实验步骤"></a>3 实验步骤</h2><h3 id="3-1-SCPU-to-PipeLine"><a href="#3-1-SCPU-to-PipeLine" class="headerlink" title="3-1 SCPU to PipeLine"></a>3-1 SCPU to PipeLine</h3><p>由上述原理图可以看到，我们在SCPU中使用的许多模块在PipeLine中仍然需要用到，且这些模块的内部结构并未发生很大变化。</p>
<p>所以为将SCPU改写成PipeLine首先要明确Pipeline的每个阶段所要用到的模块。</p>
<p>同时我们注意到除了各个阶段的划分，Pipeline中<strong>还添加了四个阶段间寄存器</strong>分别为：</p>
<p>$IF&#x2F;ID, ID&#x2F;EXE, EXE&#x2F;MEM, MEM&#x2F;WB$</p>
<p>分别在阶段和阶段间<strong>进行数据传输和信号传递</strong>。</p>
<p>所以预实验主要分为以下几个部分：</p>
<p><strong>SCPU回顾与模块划分，阶段间寄存器的设置，阶段间寄存器与模块间的布局引线。</strong></p>
<h4 id="3-1-1-SCPU回顾与模块划分"><a href="#3-1-1-SCPU回顾与模块划分" class="headerlink" title="3-1-1 SCPU回顾与模块划分"></a>3-1-1 SCPU回顾与模块划分</h4><h5 id="3-1-1-1-SCPU模块功能回顾"><a href="#3-1-1-1-SCPU模块功能回顾" class="headerlink" title="3-1-1-1 SCPU模块功能回顾"></a>3-1-1-1 SCPU模块功能回顾</h5><p>在SCPU中，我们主要有以下几个模块：</p>
<ul>
<li>ALU ： 计算模块，主要负责将传入的一组数据根据传入的操作信号（op_code）<strong>进行不同的计算操作并返回计算结果</strong></li>
<li>RAM：CPU的内存，<strong>在代码段加载程序所要运行的指令，在数据段进行内存的访问和读写</strong>。</li>
<li>Regs：寄存器组，由32个512位寄存器构成。</li>
<li>Immegen：立即数生成模块，从传入的指令中提取立即数。</li>
<li>Mux：多路选择器组，包括pc写回 Mux4，立即数选择Mux2等</li>
<li>Bomb：本人所添加的模块，用于判断两数据的大小关系（包括有符号数与无符号数）<strong>并传出less和alu_option供跳转模块判断</strong>。</li>
<li>SCPU：单周期CPU主模块，在该模块中主要进行<strong>pc的层加与inst的迭代</strong>。</li>
<li>Control: 控制模块，用于分析指令并输出控制信号。</li>
</ul>
<h5 id="3-1-1-2-根据Pipeline阶段进行模块划分"><a href="#3-1-1-2-根据Pipeline阶段进行模块划分" class="headerlink" title="3-1-1-2 根据Pipeline阶段进行模块划分"></a>3-1-1-2 根据Pipeline阶段进行模块划分</h5><p>现在我们可以根据这些模块的功能，参考Pipeline中的五个阶段简单分个类：</p>
<pre class="mermaid">graph TD;
emperor3((RAM)) .-> IF;
emperor((Regs)).->WB;
emperor .-> ID;
emperor2((Control)) .-> ID;

emperor4((ALU)).-> EXE;
emperor5((Bomb)) .-> ID;
emperor6((Immgen)) .-> ID;
emperor3 .-> MEM;
emperor7((MUX)) .-> ID;
emperor7 .-> EXE;</pre>

<p>嗯，看起来也不是很多。</p>
<p><strong>请注意！在这里我将Mux选择（寄存器or立即数）与Immgen解码均放在ID部分，ID传给EXE的只有数据和op_code。这个更改将贯通Pipeline的始终。</strong></p>
<p>具体解释一下：</p>
<ul>
<li>RAM：RAM中有数据段也有内存段，所以使用RAM结构的有两个阶段，分别是IF和MEM。但两者并不冲突：</li>
</ul>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="VERILOG"><figure class="iseeu highlight /verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RAM ram( <span class="comment">// 时序电路，均为时钟上升沿读写。</span></span><br><span class="line">    <span class="variable">.clk</span>(clk),  </span><br><span class="line">    <span class="variable">.rstn</span>(rstn),</span><br><span class="line">    <span class="variable">.rw_wmode</span>(rw_wmode), <span class="comment">//mem </span></span><br><span class="line">    <span class="variable">.rw_addr</span>(addr_out&gt;&gt;<span class="number">3</span>), <span class="comment">//mem</span></span><br><span class="line">    <span class="variable">.rw_wdata</span>(rw_wdata), <span class="comment">//mem</span></span><br><span class="line">    <span class="variable">.rw_wmask</span>(mask_offset), <span class="comment">//mem</span></span><br><span class="line">    <span class="variable">.rw_rdata</span>(Ram_to_Path_temp), <span class="comment">//mem</span></span><br><span class="line">    <span class="variable">.ro_addr</span>(((npc_sel_EXE)?pc_in:((IF_stall)?pc_IF:(pc_IF+<span class="number">4</span>)))&gt;&gt;<span class="number">3</span>),  <span class="comment">//IF</span></span><br><span class="line">    <span class="variable">.ro_rdata</span>(inst_temp)  <span class="comment">//IF</span></span><br><span class="line">); </span><br></pre></td></tr></table></figure></div>

<p><strong>可以看到对于接口来讲，MEM和IF并不冲突，且均在时钟上升沿进行取指令or读写内存，所以可以很好地共用RAM结构。</strong></p>
<ul>
<li>Regs：Regs结构需要用的阶段有WB（写回），ID译码。两者也不冲突，代码如下：</li>
</ul>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="VERILOG"><figure class="iseeu highlight /verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Regs register( <span class="comment">//Regs模块</span></span><br><span class="line">    <span class="variable">.clk</span>(clk),</span><br><span class="line">    <span class="variable">.rst</span>(rstn),</span><br><span class="line">    <span class="variable">.we</span>(reg_write),</span><br><span class="line">    <span class="variable">.read_addr_1</span>(inst_ID[<span class="number">19</span>:<span class="number">15</span>]), <span class="comment">// ID</span></span><br><span class="line">    <span class="variable">.read_addr_2</span>(inst_ID[<span class="number">24</span>:<span class="number">20</span>]), <span class="comment">// ID</span></span><br><span class="line">    <span class="variable">.write_addr</span>(inst_WB[<span class="number">11</span>:<span class="number">7</span>]), <span class="comment">// WB</span></span><br><span class="line">    <span class="variable">.write_data</span>(Ram_to_Path), <span class="comment">// WB</span></span><br><span class="line">    <span class="variable">.read_data_1</span>(read_data_1), <span class="comment">// ID</span></span><br><span class="line">    <span class="variable">.read_data_2</span>(read_data_2), <span class="comment">// ID</span></span><br><span class="line">    <span class="variable">.debug_reg</span>(debug_reg), <span class="comment">// ?</span></span><br><span class="line">    <span class="variable">.fin_reg</span>(fin_reg) <span class="comment">// ?</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<p>对于接口来讲，二者并不冲突。</p>
<p>但请注意，<strong>在Regs内部，WB的数据协会是通过时序电路控制的，也就是说，仅在时钟上升沿进行数据的传入写回</strong>。</p>
<p><strong>而ID的译码，即访问寄存器中数值是通过组合电路进行的，也就是说二者的写回和读取有可能不同步</strong>。由于我们将实验指导中推荐放在EXE阶段的MUX和Immgen均放在了ID阶段，所以这里需要特别注意，尤其是后期加入stall控制拍数的时候。</p>
<p>剩下的结构就没什么好说的了：</p>
<ul>
<li><p>Control：对传入ID阶段的指令进行译码。</p>
</li>
<li><p>Immgen：将inst中的立即数提取出来，</p>
</li>
<li><p>Mux：通过Control传出的控制信号进行数据的选择（寄存器 or 立即数）。<strong>或在EXE阶段判断指令跳转和pc写回。</strong></p>
</li>
<li><p>Bomb：在ID阶段对译码出的两操作数<strong>做预先的数值比较，为后续br_taken判断做铺垫。</strong></p>
</li>
</ul>
<p>这里展示一下Bomb的逻辑：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="VERILOG"><figure class="iseeu highlight /verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> Bomb(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">63</span>:<span class="number">0</span>]I0,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">63</span>:<span class="number">0</span>]I1,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">1</span>:<span class="number">0</span>]less,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">63</span>:<span class="number">0</span>]alu_option</span><br><span class="line">);</span><br><span class="line"><span class="keyword">reg</span> less_reg;</span><br><span class="line"><span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(I0 &lt; I1) less_reg = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> less_reg = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">assign</span> alu_option = I0 - I1;</span><br><span class="line"><span class="keyword">assign</span> less = less_reg;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></div>



<h4 id="3-1-2-阶段间寄存器的设置"><a href="#3-1-2-阶段间寄存器的设置" class="headerlink" title="3-1-2 阶段间寄存器的设置"></a>3-1-2 阶段间寄存器的设置</h4><p>首先我们应该明确什么是阶段间寄存器：</p>
<blockquote>
<p>阶段间寄存器（也称为流水线寄存器或流水线暂存器）是一种在流水线架构的处理器设计中使用的硬件元素。它位于处理器的各个流水线阶段之间，用于存储前一阶段产生的中间结果，以便下一阶段可以在下一个时钟周期中使用这些结果。</p>
<p>这样的设计可以降低不同阶段之间的依赖性，允许每个阶段独立地在其自己的速率上运行，从而提高处理器的整体性能。阶段间寄存器还有助于减少数据冒险和控制冒险，这些都是流水线设计中常见的问题。</p>
</blockquote>
<p>OK, 简而言之，我们各个阶段的执行都是同步的，也就是说，<strong>在阶段和阶段之间不可能通过组合电路连接</strong>（会产生严重的数据干扰与冲突）。换句话说，在同一个时钟周期内，阶段与阶段间的数据，信号，包括PC，INST，都是独立的，互不干扰的。</p>
<p><strong>那么在时钟信号更迭时，我们就需要一个东西在阶段间进行指令&#x2F;数据传输，以满足下一个时钟周期各个阶段有事可做。</strong></p>
<p>明确，这个东西需要有以下几点特性：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="VERILOG"><figure class="iseeu highlight /verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> IFID(</span><br><span class="line">  <span class="keyword">input</span> clk,</span><br><span class="line">  <span class="keyword">input</span> rst,</span><br><span class="line">  <span class="keyword">input</span> stall,</span><br><span class="line">  <span class="keyword">input</span> flush,</span><br><span class="line">  <span class="keyword">input</span> [<span class="number">63</span>:<span class="number">0</span>]pc_IF,</span><br><span class="line">  <span class="keyword">input</span>[<span class="number">31</span>:<span class="number">0</span>]inst_IF,</span><br><span class="line">  <span class="keyword">input</span> valid_IF,</span><br><span class="line">  <span class="keyword">input</span> [<span class="number">63</span>:<span class="number">0</span>]pc_4_IF,</span><br><span class="line">  <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">63</span>:<span class="number">0</span>]pc_ID,</span><br><span class="line">  <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>]inst_ID,</span><br><span class="line">  <span class="keyword">output</span> <span class="keyword">reg</span> valid_ID,</span><br><span class="line">  <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">63</span>:<span class="number">0</span>]pc_4_ID  </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(rst|flush)<span class="keyword">begin</span></span><br><span class="line">        pc_ID &lt;= <span class="number">64&#x27;b0</span>;</span><br><span class="line">        inst_ID &lt;= <span class="number">32&#x27;b0</span>;</span><br><span class="line">        valid_ID &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        pc_4_ID &lt;= <span class="number">64&#x27;b0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(~stall)<span class="keyword">begin</span></span><br><span class="line">        pc_ID &lt;= pc_IF;</span><br><span class="line">        inst_ID &lt;= inst_IF;</span><br><span class="line">        valid_ID &lt;= valid_IF;</span><br><span class="line">        pc_4_ID &lt;= pc_4_IF;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></div>



<ul>
<li><p><strong>时序电路控制</strong>：为了保证阶段与阶段间在同一个时钟周期内指令数据互不干扰，<strong>阶段间寄存器一定要用时序电路控制</strong>。一方面，在<strong>时钟信号更迭时可以瞬间在阶段间传递数据</strong>。另一方面，<strong>在每一个时钟周期内对相邻阶段起到保护作用，保证其独立性</strong>。</p>
</li>
<li><p><strong>信号&#x2F;数据接受与发送</strong>：阶段间寄存器一个巨大的作用是在阶段与阶段间传递指令和数据，这个功能通过一个always_pse_clk块还是很好完成的。</p>
</li>
<li><p><strong>stall与flush</strong>：我认为这是阶段间寄存器最重要的作用之一。在Pipeline中会有很多数据冲突与信号冲突。阶段间寄存器可以<strong>将产生冲突或即将产生冲突的阶段隔断，或使上一个阶段等待下一个阶段，或使下一个阶段插入bubble，来解决冲突</strong>。（在后面会着重介绍）</p>
</li>
<li><p><strong>尽可能多的数据传递</strong>：因为，也说不准后面的阶段需要什么数据或信号，那就尽量多传一点，到时候解决数据冲突也很容易。</p>
</li>
</ul>
<p>类似于上面展示出的IFID阶段间寄存器，我们可以写出IDEXE, EXEMEM, MEMWB。代码在此不表~</p>
<p><img src="/2023/11/22/Computer-System-II-Lab1-%EF%BC%9A%E5%9F%BA%E4%BA%8EStall%E7%9A%84%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF/3.png" alt="image-20231023023739091"></p>
<h4 id="3-1-3-阶段间寄存器与模块间布局引线"><a href="#3-1-3-阶段间寄存器与模块间布局引线" class="headerlink" title="3-1-3 阶段间寄存器与模块间布局引线"></a>3-1-3 阶段间寄存器与模块间布局引线</h4><p>嗯，在这个部分嘛，我们需要在通过阶段间寄存器把阶段与阶段的模块之间连上线。各个阶段间需要传递的数据主要是：</p>
<p><img src="/2023/11/22/Computer-System-II-Lab1-%EF%BC%9A%E5%9F%BA%E4%BA%8EStall%E7%9A%84%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF/4.png" alt="image-20231023024512543"></p>
<ul>
<li>IF -&gt;ID : pc, inst</li>
<li>ID -&gt; EXE: rs1, rs2, op_code, control, pc , inst, rd</li>
<li>EXE -&gt; MEM : ALU_result, control,  pc, inst, rd</li>
<li>MEM -&gt; WB : control , inst,  ALU_result, rd,  pc</li>
</ul>
<p>但实际上我们需要传递的信号与数据远远不止这些，还有比如：</p>
<ul>
<li>rs1_name&#x2F;rs2_name : 辅助冲突判断，stall的关键判断信号</li>
<li>valid_X ： 表示该阶段现处理指令是否为bubble</li>
<li>br_taken ： EXE阶段跳转指令传出信号，传入IF强行改变pc读取跳转地址处指令。并将ID,EXE现阶段指令flush掉</li>
</ul>
<p>等等。 阶段间寄存器在模块外连线如下图所示：(拿IDEXE来举例)</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="VERILOG"><figure class="iseeu highlight /verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">IDEXE IDEXE1(</span><br><span class="line">    <span class="variable">.clk</span>(clk),</span><br><span class="line">    <span class="variable">.rst</span>(!rstn),</span><br><span class="line"></span><br><span class="line">    <span class="variable">.stall</span>(IDEXE_stall),</span><br><span class="line">    <span class="variable">.flush</span>(IDEXE_flush),</span><br><span class="line"></span><br><span class="line">    <span class="variable">.pc_ID</span>(pc_ID), <span class="comment">// ID阶段的pc</span></span><br><span class="line">    <span class="variable">.pc_4_ID</span>(pc_4_ID), <span class="comment">//ID的pc+4</span></span><br><span class="line">    <span class="variable">.inst_ID</span>(inst_ID), <span class="comment">//ID阶段的inst</span></span><br><span class="line">    <span class="variable">.valid_ID</span>(valid_ID), <span class="comment">//ID阶段处理的指令是否为bubble</span></span><br><span class="line">    <span class="variable">.rs1_ID</span>(rs1_data_ID), <span class="comment">//ID阶段rs1的data</span></span><br><span class="line">    <span class="variable">.rs2_ID</span>(rs2_data_ID), <span class="comment">//ID阶段rs2的data</span></span><br><span class="line">    <span class="variable">.rs1_name_ID</span>(rs1_ID), <span class="comment">//ID阶段rs1的名称</span></span><br><span class="line">    <span class="variable">.rs2_name_ID</span>(rs2_ID), <span class="comment">//ID阶段rs2的名称</span></span><br><span class="line">    <span class="variable">.rs2_MEM_ID</span>(rs2_MEM_ID), <span class="comment">//ID阶段需要传给MEM阶段进行存内存的数据。</span></span><br><span class="line">    <span class="variable">.b_ID</span>(b_ID), <span class="comment">// ID阶段的信号控制流</span></span><br><span class="line">    <span class="variable">.alu_option_ID</span>(alu_option_ID),</span><br><span class="line">    <span class="variable">.less_ID</span>(less_ID), <span class="comment">//ID阶段的辅助跳转判断变量</span></span><br><span class="line">	<span class="comment">// input</span></span><br><span class="line">    <span class="variable">.pc_EXE</span>(pc_EXE),</span><br><span class="line">    <span class="variable">.inst_EXE</span>(inst_EXE),</span><br><span class="line">    <span class="variable">.pc_4_EXE</span>(pc_4_EXE),</span><br><span class="line">    <span class="variable">.valid_EXE</span>(valid_EXE),</span><br><span class="line">    <span class="variable">.rs1_EXE</span>(rs1_data_EXE),</span><br><span class="line">    <span class="variable">.rs2_EXE</span>(rs2_data_EXE),</span><br><span class="line">    <span class="variable">.b_EXE</span>(b_EXE),</span><br><span class="line">    <span class="variable">.rs2_MEM_EXE</span>(rs2_MEM_EXE),</span><br><span class="line">    <span class="variable">.rs1_name_EXE</span>(rs1_EXE),</span><br><span class="line">    <span class="variable">.rs2_name_EXE</span>(rs2_EXE),</span><br><span class="line">    <span class="variable">.alu_option_EXE</span>(alu_option_EXE),</span><br><span class="line">    <span class="variable">.less_EXE</span>(less_EXE)</span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<p>各种信号在每次时钟信号上升沿进行传递，在其他时间隔离，保证了阶段与阶段间指令处理的独立性。</p>
<p>按照上述IDEXE的信号传递逻辑对IFID, EXEMEM, MEMWB三模块进行模块内外的布局引线。</p>
<p><img src="/2023/11/22/Computer-System-II-Lab1-%EF%BC%9A%E5%9F%BA%E4%BA%8EStall%E7%9A%84%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF/5.png" alt="image-20231023151934792"></p>
<h3 id="3-2-Stall-and-Flush"><a href="#3-2-Stall-and-Flush" class="headerlink" title="3-2 Stall and Flush"></a>3-2 Stall and Flush</h3><p>在Pipeline中，冲突是非常常见的现象，具体分为以下几类：</p>
<ul>
<li><strong>结构冲突</strong>：是指令在重叠执行的过程中，硬件资源满足不了指令重叠执行的要求，发生硬件资源冲突而产生的冲突。</li>
</ul>
<blockquote>
<p>但在我们写的MIPS流水，使用stall方案来解决，不存在结构冲突，由此结构冲突的内容及解决方案在此不表。</p>
</blockquote>
<ul>
<li><strong>数据冲突</strong>：是指在同时重叠执行的几条指令中，一条指令依赖于前面指令执行结果数据，但是又得不到时发生的冲突。</li>
<li><strong>控制冲突</strong>：它是指流水线中的分支指令或者其他需要改写PC的指令造成的冲突。</li>
</ul>
<h4 id="3-2-1-数据冲突"><a href="#3-2-1-数据冲突" class="headerlink" title="3-2-1 数据冲突"></a>3-2-1 数据冲突</h4><p>数据冲突主要分为以下几种情况：</p>
<h5 id="3-2-1-1-写后读冲突（RAW：Read-After-Write）"><a href="#3-2-1-1-写后读冲突（RAW：Read-After-Write）" class="headerlink" title="3-2-1-1 写后读冲突（RAW：Read After Write）"></a>3-2-1-1 <strong>写后读冲突（RAW：Read After Write）</strong></h5><p>指令j的执行需要使用指令i的计算结果，但是当它们在流水线中重叠执行时，指令j可能在指令i将其计算结果写入之前就先行对保存该计算结果的寄存器进行了读操作，这样指令j读出的寄存器值就是错误的。</p>
<p>例如：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAINTEXT"><figure class="iseeu highlight /plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add x1, x2, x3</span><br><span class="line">sub x4, x5, x1</span><br></pre></td></tr></table></figure></div>

<p><strong>其中，sub指令需要用到add指令的rd寄存器x1。但当sub指令处于EXE阶段时，add指令并未进行写回，也就是说，sub指令需要等待add指令写回之后才可进行EXE的操作，此时得到的x1的值是写回之后的新值。</strong></p>
<h5 id="3-2-1-2-写后写冲突（WAW：Write-After-Write）"><a href="#3-2-1-2-写后写冲突（WAW：Write-After-Write）" class="headerlink" title="3-2-1-2 写后写冲突（WAW：Write After Write）"></a>3-2-1-2 写后写冲突（WAW：Write After Write）</h5><p>指令j和指令i的目的操作数相同，但是当它们在流水线中重叠执行时，指令j可能在指令i将其计算结果写入之前就先行对保存该计算结果的寄存器进行了写操作，这样就导致了寄存器写入顺序的错误，此时，目的寄存器的内容是指令i写入的值，而不是指令j写入的值。（i把j结果冲掉了）</p>
<p><strong>通俗来讲，也就是我们所说的吞指令。</strong></p>
<p>但在我们的MIPS指令流水中<strong>并不会发生WAW冲突，只有RAW冲突。</strong></p>
<h4 id="3-2-2-控制冲突"><a href="#3-2-2-控制冲突" class="headerlink" title="3-2-2 控制冲突"></a>3-2-2 控制冲突</h4><p>控制冲突主要发生在 <code>bne,beq,jal,jalr</code>等跳转指令的执行过程中。</p>
<blockquote>
<p>在我们所写的MIPS指令流水中，默认把跳转判断放在EXE阶段进行。当然该判断可以放在EXE之后的任何阶段，只不过需要bubble次数更多，CPU性能会有所下降而已~</p>
</blockquote>
<p>当EXE阶段判断指令跳转时，需要更改pcIF为跳转的pc，并将IF, ID的现处理指令flush掉。</p>
<h4 id="3-2-3-RaceControl"><a href="#3-2-3-RaceControl" class="headerlink" title="3-2-3 RaceControl"></a>3-2-3 RaceControl</h4><p><strong>那么为了解决数据冲突和控制冲突，我们需要两个信号去控制阶段间寄存器，让他们在本拍内：</strong></p>
<ul>
<li><strong>暂停数据传输</strong> –&gt; stall</li>
<li><strong>插入空指令（bubble）</strong> –&gt;flush</li>
</ul>
<p>首先我们需要Pipeline中另一个非常重要的模块去给四个阶段间寄存器传输stall和flush信号。</p>
<p>也就是RaceControl模块</p>
<pre class="mermaid">graph TD;
empe(RaceControl) -.Stall/flush.-> IF;
empe(RaceControl) -.Stall/flush.-> IF/ID;
empe(RaceControl) -.Stall/flush.-> ID/EXE;
empe(RaceControl) -.Stall/flush.-> EXE/MEM;
empe(RaceControl) -.Stall/flush.-> MEM/WB;</pre>

<p>下面我们推演一下，如何通过stall和flush去正确执行两拍具有数据冲突和控制冲突的指令</p>
<h5 id="3-2-3-1-数据冲突stall推演"><a href="#3-2-3-1-数据冲突stall推演" class="headerlink" title="3-2-3-1 数据冲突stall推演"></a>3-2-3-1 数据冲突stall推演</h5><p>现在我们有两条指令：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAINTEXT"><figure class="iseeu highlight /plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add x1, x3, x4</span><br><span class="line">sub x5, x2, x1</span><br></pre></td></tr></table></figure></div>

<p>现在我们将第一条指令统称为ADD，第二条指令成为SUB,bubble的指令成为NOP。<strong>（默认ADD的前继指令均为NOP）</strong></p>
<ul>
<li>在利用Pipeline处理这两条指令时，ADD先进入，SUB后进入，假设此时ADD到了ID阶段，SUB则应在IF阶段。</li>
</ul>
<pre class="mermaid">graph TD;
IF --> SUB;
ID --> ADD;
EXE --> NOP;
MEM --> NOP;
WB --> NOP;</pre>

<ul>
<li>走一拍，此时ADD到了EXE阶段，SUB到了IF阶段。</li>
</ul>
<pre class="mermaid">graph TD;
IF --> O(NOP);
ID --> SUB;
EXE --> ADD;
MEM --> NOP;
WB --> NOP;</pre>

<p>此时EXE阶段执行操作数的计算。我们再走一拍试试看：</p>
<pre class="mermaid">graph TD;
IF --> O(NOP);
ID --> O;
EXE --> SUB;
MEM --> ADD;
WB --> NOP;</pre>

<p>此时SUB指令到了EXE阶段。这时我们对SUB指令的操作数进行分析：</p>
<pre class="mermaid">graph LR;
SUB .-> rs1 .-> x2;
SUB .->rs2 .-> x1;
ADD .-> rd .-> WB .-> x1;</pre>

<p><strong>也就是说，SUB指令的操作数x1是ADD指令的rd寄存器且当SUB指令执行到EXE阶段时，ADD指令还没有进行x1的写回，导致数据冲突。</strong>这时候我们不能让它再走了，要将SUB指令在ID段停住，等待ADD指令走完。</p>
<ul>
<li>RaceControl触发，ID_EXE_STALL，IF_ID_STALL，PC_STALL</li>
</ul>
<blockquote>
<p>因为停ID不能只停ID，前面的所有阶段都要等待EXE，MEM，WB走完，所以当IDstall的时候IF, PC也不能走。</p>
</blockquote>
<pre class="mermaid">graph LR;
RaceControl -.Stall.-> IF --> O(NOP);
RaceControl -.Stall.-> ID --> SUB;
RaceControl -.Flush.-> EXE --> O1(BUBBLE);
RaceControl -.->MEM --> ADD;
RaceControl -.->WB --> NOP;</pre>

<ul>
<li>等待3拍，ADD指令走完，SUB指令STALL解除。继续执行。此时x1寄存器已经协会，数据冲突解除。</li>
</ul>
<p><strong>由此可知：</strong></p>
<ul>
<li><p><strong>当发生数据冲突时，必须在冲突的两条指令在ID, EXE阶段就进行STALL信号的传输</strong></p>
</li>
<li><p><strong>后一条指令必须等前一条指令走完全程，才可以解除STALL</strong></p>
</li>
<li><p>发生数据冲突，只有IF, ID在Stall， EXE插Bubble</p>
</li>
</ul>
<p>我们可以利用如下的表达式判断是否需要Stall：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="VERILOG"><figure class="iseeu highlight /verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data_race_if = ((((rs1_ID == rd_EXE)|(rs2_ID == rd_EXE))&amp;(rd_reg_write))|((re_MEM_MEM)&amp;((rs1_ID == rd_MEM)|(rs2_ID == rd_MEM)))|((reg_WB)&amp;((rs1_ID == rd_WB)|(rs2_ID == rd_WB))));</span><br></pre></td></tr></table></figure></div>

<p><strong>简而言之，只要ID阶段的rs1和rs2和EXE,MEM,WB阶段的任何一个rd相等，都需要Stall，等待冲突的那条指令走完</strong></p>
<h5 id="3-2-3-2-控制冲突Stall推演"><a href="#3-2-3-2-控制冲突Stall推演" class="headerlink" title="3-2-3-2 控制冲突Stall推演"></a>3-2-3-2 控制冲突Stall推演</h5><p>控制冲突发生在指令跳转的时候。我们有如下代码段：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAINTEXT"><figure class="iseeu highlight /plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">beq x0, 0, label</span><br><span class="line">add ...</span><br><span class="line">sub ...</span><br><span class="line">...</span><br><span class="line">Label:</span><br><span class="line">lui .....</span><br></pre></td></tr></table></figure></div>

<p>假定beq指令发生跳转，且我们判断跳转并触发控制冲突的阶段为EXE。</p>
<ul>
<li>现在假设beq指令走到EXE阶段</li>
</ul>
<pre class="mermaid">graph TD;
IF --> SUB;
ID --> ADD;
EXE --> BEQ;
MEM --> NOP;
WB --> NOP;</pre>

<ul>
<li>判断跳转，<strong>EXE阶段计算出跳转的地址并传出跳转信号给IF阶段，改变下一条指令的pc, 并改变IF当前所取的指令</strong>：</li>
</ul>
<pre class="mermaid">graph LR;
EXE -.-> PC_jump;
EXE -.-> br_taken --> IF;
IF -.-> pc-next --> PC_jump;
IF --> inst;
PC_jump --> RAM --> inst;</pre>

<ul>
<li><strong>ID阶段刷新, EXE阶段插入bubble</strong>,走一拍：</li>
</ul>
<pre class="mermaid">graph TD;
IF --> lui;
ID --> NOP;
EXE --> NOP;
MEM --> BEQ;
WB --> O(NOP);</pre>

<p>这样我们就解决了控制冲突。</p>
<p>下面我们可以根据上述的推演写出RaceControl的代码：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="VERILOG"><figure class="iseeu highlight /verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> RaceControl(</span><br><span class="line">    <span class="comment">// input IF_stall,</span></span><br><span class="line">    <span class="comment">// input MEM_stall,</span></span><br><span class="line">    <span class="keyword">input</span> npc_sel_EXE,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">input</span> [<span class="number">4</span>:<span class="number">0</span>]rs1_ID,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">4</span>:<span class="number">0</span>]rs2_ID,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// input [4:0]rs1_EXE,</span></span><br><span class="line">    <span class="comment">// input rs1_use_EXE,</span></span><br><span class="line">    <span class="comment">// input [4:0]rs2_EXE,</span></span><br><span class="line">    <span class="comment">// input rs2_use_EXE,</span></span><br><span class="line">    <span class="keyword">input</span> [<span class="number">4</span>:<span class="number">0</span>]rd_EXE,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">4</span>:<span class="number">0</span>]rd_MEM,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">4</span>:<span class="number">0</span>]rd_WB,</span><br><span class="line">    <span class="keyword">input</span> rd_reg_write,</span><br><span class="line">    <span class="keyword">input</span> re_MEM_MEM,</span><br><span class="line">    <span class="keyword">input</span> we_MEM_EXE,</span><br><span class="line">    <span class="keyword">input</span> reg_WB,</span><br><span class="line">    <span class="keyword">output</span> IF_stall,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// output MEM_stall,</span></span><br><span class="line">    <span class="keyword">output</span> pc_stall,</span><br><span class="line">    <span class="keyword">output</span> IFID_stall,</span><br><span class="line">    <span class="keyword">output</span> IFID_flush,</span><br><span class="line">    <span class="keyword">output</span> IDEXE_flush,</span><br><span class="line">    <span class="keyword">output</span> IDEXE_stall</span><br><span class="line"></span><br><span class="line">    <span class="comment">// output EXEMEM_stall,</span></span><br><span class="line">    <span class="comment">// output EXEMEM_flush</span></span><br><span class="line">    <span class="comment">// output MEMWB_stall,</span></span><br><span class="line">    <span class="comment">// output MEMWB_flush</span></span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">wire</span> data_race_if = ((((rs1_ID == rd_EXE)|(rs2_ID == rd_EXE))&amp;(rd_reg_write))|((re_MEM_MEM)&amp;((rs1_ID == rd_MEM)|(rs2_ID == rd_MEM)))|((reg_WB)&amp;((rs1_ID == rd_WB)|(rs2_ID == rd_WB))));</span><br><span class="line"><span class="keyword">wire</span> predict_flush = npc_sel_EXE;</span><br><span class="line"><span class="keyword">assign</span> IF_stall = data_race_if;</span><br><span class="line"><span class="keyword">assign</span> pc_stall = IF_stall;</span><br><span class="line"><span class="keyword">assign</span> IFID_stall = data_race_if  ;</span><br><span class="line"><span class="keyword">assign</span> IFID_flush = ~IFID_stall &amp; IF_stall | predict_flush;</span><br><span class="line"><span class="keyword">assign</span> IDEXE_stall = data_race_if;</span><br><span class="line"><span class="keyword">assign</span> IDEXE_flush = IDEXE_stall | predict_flush;</span><br><span class="line"></span><br><span class="line"><span class="comment">// assign EXEMEM_flush = predict_flush;</span></span><br><span class="line"><span class="comment">// assign EXEMEM_stall = </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></div>



<h3 id="3-3-Dram-to-Bram"><a href="#3-3-Dram-to-Bram" class="headerlink" title="3-3 Dram to Bram"></a>3-3 Dram to Bram</h3><p>在MEM访存阶段，我们在SCPU中使用的是Dram，而在Pipeline中需要改成Bram。</p>
<blockquote>
<ul>
<li><p>DRAM代表动态随机存取存储器（Dynamic Random Access Memory）。它是一种常见的随机存储器，用于存储数据和指令。DRAM使用电容存储数据，需要定期刷新电容以保持数据的稳定性。它是易失性存储器，意味着当电源关闭时，存储在DRAM中的数据将会丢失。DRAM的优点包括较高的存储密度和相对较低的成本，但它的访问速度相对较慢。</p>
</li>
<li><p>BRAM代表块随机存取存储器（Block Random Access Memory）。它是一种集成在现场可编程逻辑器件（FPGA）中的存储器类型。BRAM是用于在FPGA中存储数据和配置信息的内部存储器。与DRAM不同，BRAM是静态存储器，它使用触发器来存储数据，无需刷新操作。BRAM的优点包括较快的访问速度、低功耗和可编程性。它在FPGA设计中经常用于实现缓冲区、存储器和算法逻辑等功能。</p>
</li>
</ul>
</blockquote>
<p>最大的区别是：</p>
<p><strong>在取内存的时候不能再一个时钟周期内就取出，需要在上一个时钟周期就把需要读&#x2F;写的地址传入RAM，在下一个时钟周期才能将数据读出来&#x2F;写进去。由此，为保证MEM阶段就已经完成数据的读出&#x2F;写入，我们需要把大部分的内存操作提前一拍，即在EXE阶段完成：</strong></p>
<p>使用Dram的模块划分：</p>
<pre class="mermaid">graph TD;
EXE;
MEM --> Datatrunc;
MEM --> Maskgen;
MEM --> DataPKG;</pre>

<p>现在为在MEM阶段就已经完成数据的读出&#x2F;写入，<strong>我们需要将将MaskGen，DataPKG模块提前一拍，即在EXE阶段完成</strong>：</p>
<pre class="mermaid">graph TD;
EXE --> DataPKG;
EXE --> MaskGen;
MEM --> DataTrunc;</pre>

<p>DataTrunc模块作用是将读出的数据进行加工，所以在MEM阶段进行即可。</p>
<p>EXE阶段的执行代码：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="VERILOG"><figure class="iseeu highlight /verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> EXE(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>]inst,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>]pc,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">21</span>:<span class="number">0</span>]b,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">63</span>:<span class="number">0</span>]rs1,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">63</span>:<span class="number">0</span>]rs2,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">63</span>:<span class="number">0</span>]alu_option,</span><br><span class="line">    <span class="keyword">input</span> valid_EXE,</span><br><span class="line">    <span class="keyword">input</span> less,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">4</span>:<span class="number">0</span>]rs1_name,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">4</span>:<span class="number">0</span>]rs2_name,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">63</span>:<span class="number">0</span>]rs2_MEM_EXE,</span><br><span class="line">    <span class="keyword">output</span> rd_reg_write_EXE,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">63</span>:<span class="number">0</span>]ALU_result,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">63</span>:<span class="number">0</span>]pc_next,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">4</span>:<span class="number">0</span>]rd_EXE,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">63</span>:<span class="number">0</span>]addr_out,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>]mask_offset,</span><br><span class="line">    <span class="keyword">output</span> rw_wmode,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">63</span>:<span class="number">0</span>]rw_wdata,</span><br><span class="line">    <span class="keyword">output</span> br_taken</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">ALU alu( <span class="comment">//ALU计算模块</span></span><br><span class="line">    <span class="variable">.a</span>(rs1),</span><br><span class="line">    <span class="variable">.b</span>(rs2),</span><br><span class="line">    <span class="variable">.alu_op</span>(b[<span class="number">15</span>:<span class="number">12</span>]), </span><br><span class="line">    <span class="variable">.res_p</span>(ALU_result)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// wire [63:0]pc_next;</span></span><br><span class="line"><span class="comment">// wire br_taken;</span></span><br><span class="line"><span class="keyword">assign</span> rd_reg_write_EXE = b[<span class="number">21</span>];</span><br><span class="line"><span class="keyword">wire</span> pc_src;</span><br><span class="line"><span class="keyword">assign</span> pc_src = b[<span class="number">19</span>];</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">2</span>:<span class="number">0</span>]bralu_op;</span><br><span class="line"><span class="keyword">assign</span> bralu_op = b[<span class="number">11</span>:<span class="number">9</span>];</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">63</span>:<span class="number">0</span>]pc_wire;</span><br><span class="line"><span class="keyword">assign</span> pc_wire = pc;</span><br><span class="line"><span class="keyword">assign</span> rd_EXE = inst[<span class="number">11</span>:<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">Mux4_32_pc mux3( <span class="comment">//Mux4_32_pc模块</span></span><br><span class="line">    <span class="variable">.I0</span>(pc_wire + <span class="number">4</span>),</span><br><span class="line">    <span class="variable">.I1</span>(ALU_result),</span><br><span class="line">    <span class="variable">.K</span>(pc_src), <span class="comment">// wire pc_src = b[19];</span></span><br><span class="line">    <span class="variable">.branch_and</span>(bralu_op), <span class="comment">// assign bralu_op =  b[11:9];</span></span><br><span class="line">    <span class="variable">.alu_option</span>(alu_option),</span><br><span class="line">    <span class="variable">.less</span>(less),</span><br><span class="line">    <span class="variable">.result</span>(pc_next),</span><br><span class="line">    <span class="variable">.br_taken</span>(br_taken)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------MEM--------------------------------//</span></span><br><span class="line"><span class="keyword">assign</span> addr_out = ALU_result;</span><br><span class="line"><span class="keyword">assign</span> rw_wmode = b[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>]mask;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">2</span>:<span class="number">0</span>]width = b[<span class="number">2</span>:<span class="number">0</span>];</span><br><span class="line"><span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span>(width)</span><br><span class="line">    <span class="number">3&#x27;b000</span> :<span class="keyword">begin</span> mask = <span class="number">8&#x27;b00000000</span>;<span class="keyword">end</span></span><br><span class="line">    <span class="number">3&#x27;b001</span> : <span class="keyword">begin</span> mask = <span class="number">8&#x27;b11111111</span>;<span class="keyword">end</span></span><br><span class="line">    <span class="number">3&#x27;b010</span> : <span class="keyword">begin</span> mask = <span class="number">8&#x27;b00001111</span>;<span class="keyword">end</span></span><br><span class="line">    <span class="number">3&#x27;b011</span> :<span class="keyword">begin</span> mask = <span class="number">8&#x27;b00000011</span>;<span class="keyword">end</span></span><br><span class="line">    <span class="number">3&#x27;b100</span> :<span class="keyword">begin</span>  mask = <span class="number">8&#x27;b00000001</span>;<span class="keyword">end</span></span><br><span class="line">    <span class="number">3&#x27;b101</span> :<span class="keyword">begin</span>  mask = <span class="number">8&#x27;b00001111</span>;<span class="keyword">end</span></span><br><span class="line">    <span class="number">3&#x27;b110</span> :<span class="keyword">begin</span>  mask = <span class="number">8&#x27;b00000011</span>;<span class="keyword">end</span></span><br><span class="line">    <span class="number">3&#x27;b111</span> :<span class="keyword">begin</span>  mask = <span class="number">8&#x27;b00000001</span>; <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">default</span> : <span class="keyword">begin</span></span><br><span class="line">        mask = <span class="number">8&#x27;b11111111</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endcase</span> </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> rw_wdata = rs2_MEM_EXE &lt;&lt; (&#123;<span class="number">3&#x27;b0</span>,addr_out[<span class="number">2</span>:<span class="number">0</span>]&#125;&lt;&lt;<span class="number">3</span>); <span class="comment">/*Path to Ram*/</span></span><br><span class="line"><span class="keyword">assign</span> mask_offset[<span class="number">7</span>:<span class="number">0</span>] = mask[<span class="number">7</span>:<span class="number">0</span>] &lt;&lt; (&#123;<span class="number">1&#x27;b0</span>,addr_out[<span class="number">2</span>:<span class="number">0</span>]&#125;);</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></div>

<p>这样就可以避免在执行sd，ld指令的时候因为Bram与Dram的差异而产生冲突啦~。</p>
<h2 id="4-仿真与上板测试："><a href="#4-仿真与上板测试：" class="headerlink" title="4 仿真与上板测试："></a>4 仿真与上板测试：</h2><p><strong>现在我们已经完成了所有Pipeline的模块编写，下面开始测试：</strong></p>
<h3 id="4-1-仿真测试："><a href="#4-1-仿真测试：" class="headerlink" title="4-1 仿真测试："></a>4-1 仿真测试：</h3><p>将lab1文件夹中的v文件移至上学期的lab5文件夹并执行<code>make TESTCASE=full</code>样例测试：</p>
<p>pass~</p>
<p><img src="/2023/11/22/Computer-System-II-Lab1-%EF%BC%9A%E5%9F%BA%E4%BA%8EStall%E7%9A%84%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF/6.png" alt="image-20231023181648041"></p>
<h4 id="4-2-上板测试："><a href="#4-2-上板测试：" class="headerlink" title="4-2 上板测试："></a>4-2 上板测试：</h4><p>拨下debug开关，观察pc_WB，数值为9A8，pass~</p>
<p><img src="/2023/11/22/Computer-System-II-Lab1-%EF%BC%9A%E5%9F%BA%E4%BA%8EStall%E7%9A%84%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF/7.jpg" alt="image-20231023181648041"></p>
<h2 id="5-Questions"><a href="#5-Questions" class="headerlink" title="5 Questions"></a>5 Questions</h2><p><img src="/2023/11/22/Computer-System-II-Lab1-%EF%BC%9A%E5%9F%BA%E4%BA%8EStall%E7%9A%84%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF/6.png" alt="image-20231023182339155">8.png)</p>
<h3 id="5-1-Test1-CPI"><a href="#5-1-Test1-CPI" class="headerlink" title="5-1 Test1 CPI"></a>5-1 Test1 CPI</h3><p>代码段如下，起始pc &#x3D; 0xc ，结束pc &#x3D; 0x24</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAINTEXT"><figure class="iseeu highlight /plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">000000000000000c &lt;fibonacci&gt;:</span><br><span class="line">   c:	002081b3          	add	gp,ra,sp</span><br><span class="line">  10:	003100b3          	add	ra,sp,gp</span><br><span class="line">  14:	00308133          	add	sp,ra,gp</span><br><span class="line">  18:	fff20213          	addi	tp,tp,-1</span><br><span class="line">  1c:	fe4018e3          	bne	zero,tp,c &lt;fibonacci&gt;</span><br><span class="line">  20:	63d00293          	addi	t0,zero,1597</span><br><span class="line">  24:	0c511e63          	bne	sp,t0,100 &lt;fail&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h4 id="5-1-2-PipeLine-CPU"><a href="#5-1-2-PipeLine-CPU" class="headerlink" title="5-1-2 PipeLine CPU"></a>5-1-2 PipeLine CPU</h4><p>使用Pipeline CPU运行syn.hex，<code>make wave</code>观察仿真波形，调取test1处的的波段，<strong>计算运行的周期数（T）和指令条数（N）</strong>，算出CPI。</p>
<p>起始时间$Start_time&#x3D;23ps$</p>
<p><img src="/2023/11/22/Computer-System-II-Lab1-%EF%BC%9A%E5%9F%BA%E4%BA%8EStall%E7%9A%84%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF/9.png" alt="image-20231023195135453">9.png)</p>
<p>结束时间$Finish_time&#x3D;201ps$</p>
<p><img src="/2023/11/22/Computer-System-II-Lab1-%EF%BC%9A%E5%9F%BA%E4%BA%8EStall%E7%9A%84%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF/10.png" alt="image-20231023195337350"></p>
<p>周期数 $T &#x3D; \frac{Finish_time - Start_time}{2ps} &#x3D; 89$</p>
<p>共执行的指令条数 $N &#x3D; 27$</p>
<p>所以<br>$$<br>CPI_{pipeline} &#x3D; \frac{T}{N} &#x3D; 3.296<br>$$</p>
<h4 id="5-1-3-SCPU"><a href="#5-1-3-SCPU" class="headerlink" title="5-1-3 SCPU"></a>5-1-3 SCPU</h4><p>使用SCPU 运行syn.hex， <code>make wave</code>观察仿真波形，调取test1处的的波段，<strong>计算运行的周期数（T）和指令条数（N）</strong>，算出CPI。</p>
<p>起始时间$Start_time &#x3D; 17ps$</p>
<p><img src="/2023/11/22/Computer-System-II-Lab1-%EF%BC%9A%E5%9F%BA%E4%BA%8EStall%E7%9A%84%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF/11.png" alt="image-20231023183034058"></p>
<p>结束时间$Finish_time&#x3D;71ps$</p>
<p><img src="/2023/11/22/Computer-System-II-Lab1-%EF%BC%9A%E5%9F%BA%E4%BA%8EStall%E7%9A%84%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF/12.png" alt="image-20231023183216110"></p>
<p>周期数 $T &#x3D; \frac{Finish_time - Start_time}{2ps} &#x3D; 27$</p>
<p>共执行的指令条数 $N &#x3D; 27$</p>
<p>所以<br>$$<br>CPI_{scpu} &#x3D; \frac{T}{N} &#x3D; 1<br>$$<br>综上$CPI_{pipeline} &#x2F; CPI_{scpu} &#x3D; 3.296$</p>
<h3 id="5-2-Test2-CPI"><a href="#5-2-Test2-CPI" class="headerlink" title="5-2 Test2 CPI"></a>5-2 Test2 CPI</h3><p>代码段如下, 起始pc &#x3D; 0x28，结束pc &#x3D; 0x8c</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAINTEXT"><figure class="iseeu highlight /plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">0000000000000028 &lt;test2&gt;:</span><br><span class="line">  28:	11000113          	addi	sp,zero,272</span><br><span class="line">  2c:	15000193          	addi	gp,zero,336</span><br><span class="line">  30:	00010083          	lb	ra,0(sp)</span><br><span class="line">  34:	00118023          	sb	ra,0(gp)</span><br><span class="line">  38:	00110083          	lb	ra,1(sp)</span><br><span class="line">  3c:	001180a3          	sb	ra,1(gp)</span><br><span class="line">  40:	00211083          	lh	ra,2(sp)</span><br><span class="line">  44:	00119123          	sh	ra,2(gp)</span><br><span class="line">  48:	00412083          	lw	ra,4(sp)</span><br><span class="line">  4c:	0011a223          	sw	ra,4(gp)</span><br><span class="line">  50:	00813083          	ld	ra,8(sp)</span><br><span class="line">  54:	0011b423          	sd	ra,8(gp)</span><br><span class="line">  58:	00014083          	lbu	ra,0(sp)</span><br><span class="line">  5c:	0011b823          	sd	ra,16(gp)</span><br><span class="line">  60:	00010083          	lb	ra,0(sp)</span><br><span class="line">  64:	0011bc23          	sd	ra,24(gp)</span><br><span class="line">  68:	00015083          	lhu	ra,0(sp)</span><br><span class="line">  6c:	0211b023          	sd	ra,32(gp)</span><br><span class="line">  70:	00011083          	lh	ra,0(sp)</span><br><span class="line">  74:	0211b423          	sd	ra,40(gp)</span><br><span class="line">  78:	00016083          	lwu	ra,0(sp)</span><br><span class="line">  7c:	0211b823          	sd	ra,48(gp)</span><br><span class="line">  80:	00012083          	lw	ra,0(sp)</span><br><span class="line">  84:	0211bc23          	sd	ra,56(gp)</span><br><span class="line">  88:	00800093          	addi	ra,zero,8</span><br><span class="line">  8c:	00800293          	addi	t0,zero,8</span><br></pre></td></tr></table></figure></div>

<h4 id="5-2-2-PipeLine-CPU"><a href="#5-2-2-PipeLine-CPU" class="headerlink" title="5-2-2 PipeLine CPU"></a>5-2-2 PipeLine CPU</h4><p>使用Pipeline CPU运行syn.hex，<code>make wave</code>观察仿真波形，调取test1处的的波段，<strong>计算运行的周期数（T）和指令条数（N）</strong>，算出CPI。</p>
<p>起始时间$Start_time&#x3D;187ps$</p>
<p><img src="/2023/11/22/Computer-System-II-Lab1-%EF%BC%9A%E5%9F%BA%E4%BA%8EStall%E7%9A%84%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF/13.png" alt="image-20231023201537456"></p>
<p>结束时间$Finish_time&#x3D;323ps$</p>
<p><img src="/2023/11/22/Computer-System-II-Lab1-%EF%BC%9A%E5%9F%BA%E4%BA%8EStall%E7%9A%84%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF/14.png" alt="image-20231023201558445"></p>
<p>周期数 $T &#x3D; \frac{Finish_time - Start_time}{2ps} &#x3D; 68$</p>
<p>共执行的指令条数 $N &#x3D; 26$</p>
<p>所以<br>$$<br>CPI_{pipeline} &#x3D; \frac{T}{N} &#x3D; 2.615<br>$$</p>
<h4 id="5-2-3-SCPU"><a href="#5-2-3-SCPU" class="headerlink" title="5-2-3 SCPU"></a>5-2-3 SCPU</h4><p>使用SCPU 运行syn.hex， <code>make wave</code>观察仿真波形，调取test1处的的波段，<strong>计算运行的周期数（T）和指令条数（N）</strong>，算出CPI。</p>
<p>起始时间$Start_time&#x3D;71ps$</p>
<p><img src="/2023/11/22/Computer-System-II-Lab1-%EF%BC%9A%E5%9F%BA%E4%BA%8EStall%E7%9A%84%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF/15.png" alt="image-20231023194035203"></p>
<p>结束时间$Finish_time&#x3D;123ps$</p>
<p><img src="/2023/11/22/Computer-System-II-Lab1-%EF%BC%9A%E5%9F%BA%E4%BA%8EStall%E7%9A%84%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF/16.png" alt="image-20231023194134229"></p>
<p>周期数 $T &#x3D; \frac{Finish_time - Start_time}{2ps} &#x3D; 26$</p>
<p>共执行的指令条数 $N &#x3D; 26$</p>
<p>所以<br>$$<br>CPI_{scpu} &#x3D; \frac{T}{N} &#x3D; 1<br>$$<br>综上$CPI_{pipeline} &#x2F; CPI_{scpu} &#x3D; 2.615$</p>
<h3 id="5-3-冲突情况归纳"><a href="#5-3-冲突情况归纳" class="headerlink" title="5-3 冲突情况归纳"></a>5-3 冲突情况归纳</h3><h4 id="5-3-1-数据冲突（Data-Hazards）："><a href="#5-3-1-数据冲突（Data-Hazards）：" class="headerlink" title="5-3-1 数据冲突（Data Hazards）："></a>5-3-1 数据冲突（Data Hazards）：</h4><ul>
<li><p><strong>读后写（Read After Write，RAW）冲突</strong>：当一个指令在写入某个数据之后，紧接着的另一个指令要读取同一数据时发生。这可能导致后续指令读取到旧的数据值，因为写操作尚未完成。</p>
</li>
<li><p><strong>写后读（Write After Read，WAR）冲突</strong>：当一个指令在读取某个数据之后，紧接着的另一个指令要写入同一数据时发生。这可能导致后续指令读取到错误的数据，因为写操作会改变数据的值。</p>
</li>
<li><p><strong>写后写（Write After Write，WAW）冲突</strong>：当两个指令依次写入同一数据时发生。这可能导致后续指令读取到错误的数据，因为写操作之间存在竞争条件。</p>
</li>
</ul>
<p><strong>但请注意，在我们的Stall，MIPS流水中只存在WAR冲突，不存在其他两种冲突。</strong></p>
<h4 id="5-3-2-控制冲突（Control-Hazards）："><a href="#5-3-2-控制冲突（Control-Hazards）：" class="headerlink" title="5-3-2 控制冲突（Control Hazards）："></a>5-3-2 控制冲突（Control Hazards）：</h4><ul>
<li><p><strong>分支冲突（Branch Hazards）</strong>：当程序中的条件分支指令（如if语句或循环）无法立即确定分支目标时发生。这会导致流水线中的指令预测错误，需要清空流水线并重新开始执行。</p>
</li>
<li><p><strong>跳转冲突（Jump Hazards）</strong>：当程序中的无条件跳转指令（如函数调用或跳转表）无法立即确定跳转目标时发生。与分支冲突类似，跳转冲突也会导致流水线中的指令预测错误，需要清空流水线（flush）重新开始执行。</p>
</li>
</ul>
<p>更加具体的分析请看报告 <strong>3-2 Stall and Flush</strong></p>
<h3 id="5-4-ID与EXE-MEM-WB多阶段冲突"><a href="#5-4-ID与EXE-MEM-WB多阶段冲突" class="headerlink" title="5-4 ID与EXE,MEM,WB多阶段冲突"></a>5-4 ID与EXE,MEM,WB多阶段冲突</h3><p>这个部分我们已经在 <strong>3-2-3-1 数据冲突与stall推演</strong> 中详细介绍过了。</p>
<p>首先需要明确，如果两条指令发生冲突并且stall正常作用，那么以下几种情况是<strong>不可能存在</strong>的。</p>
<ul>
<li><strong>后一条指令当前阶段处于前一条指令之后，或与前一条指令处于相同阶段。</strong> (I)</li>
<li><strong>后一条指令在EXE,MEM,WB的任一阶段时，前一条指令也位于其一。</strong>（II）</li>
<li><strong>后一条指令位于EXE阶段时，前一条指令仍未退出流水线。</strong>（III）</li>
</ul>
<p>综上所述，如果ID阶段的读寄存器和EXE,MEM,WB阶段的多阶段写寄存器发生冲突的话，需要满足：</p>
<ul>
<li><strong>位于EXE,MEM,WB三阶段的指令互不冲突：</strong></li>
</ul>
<blockquote>
<p>由II得，若EXE,MEM,WB阶段中存在互相冲突的指令，那么后一条指令本应的ID阶段就Stall住，不可能进入EXE及后续阶段。</p>
</blockquote>
<ul>
<li><p><strong>结论：由此，我们可以得到，ID阶段读寄存器与三阶段多个写寄存器冲突的情况其实与 3-2-3-1中分析的情况的解决方案是一样的，因为EXE,MEM,WB阶段的指令互不冲突，那么他们就可以按照正常流水执行，位于ID阶段的指令只要等到最后一条与之冲突的指令退出流水线，再执行就OK了</strong> 。最后一条冲突指令位于<strong>EXE&#x2F;MEM&#x2F;WB</strong>时，只需将<strong>IF, ID, PC stall 3&#x2F;2&#x2F;1</strong>拍，EXE阶段不断插入Bubble即可。</p>
</li>
<li><p>例如：</p>
</li>
</ul>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAINTEXT"><figure class="iseeu highlight /plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add x1, .... // WB</span><br><span class="line">sub x1, .... // MEM</span><br><span class="line">ld x1, .... // EXE</span><br><span class="line">sltu x2, x1, 0x10 // ID</span><br></pre></td></tr></table></figure></div>

<p>此时，stall三拍，等待前三条指令退出流水线</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAINTEXT"><figure class="iseeu highlight /plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add x1, .... // over</span><br><span class="line">sub x1, .... // over</span><br><span class="line">ld x1, .... // over</span><br><span class="line">nop // WB</span><br><span class="line">nop // MEM</span><br><span class="line">nop // EXE</span><br><span class="line">sltu x2, x1, 0x10 // ID</span><br></pre></td></tr></table></figure></div>

<p>ID阶段指令再进入EXE顺序执行就OK了。</p>
<h3 id="5-5-数据冲突和控制冲突同时发生"><a href="#5-5-数据冲突和控制冲突同时发生" class="headerlink" title="5-5 数据冲突和控制冲突同时发生"></a>5-5 数据冲突和控制冲突同时发生</h3><p>有如下代码段：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAINTEXT"><figure class="iseeu highlight /plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add x1, x2, x3</span><br><span class="line">beq x0, 0, label</span><br><span class="line">sub x4, x5, x1 // 与add指令冲突</span><br></pre></td></tr></table></figure></div>

<p>当 ADD指令到MEM阶段时，BEQ指令在EXE阶段，SUB指令在ID阶段，此时：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAINTEXT"><figure class="iseeu highlight /plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add x1, x2, x3 // MEM</span><br><span class="line">beq x0, 0, label // EXE</span><br><span class="line">sub x4, x5, x1  // ID</span><br></pre></td></tr></table></figure></div>

<p>现在，由于$ID_rs2 &#x3D; MEM_rd $且 $br_taken &#x3D; 1$出现了数据冲突与控制冲突同时发生的情况</p>
<p>这种情况下我们采取<strong>控制冲突优先</strong>的手段处理即：</p>
<ul>
<li>EXE阶段之后的指令正常执行，<strong>IF , ID阶段flush信号触发， 在EXE阶段插入bubble</strong></li>
</ul>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAINTEXT"><figure class="iseeu highlight /plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add .. //WB</span><br><span class="line">beq .. //MEM</span><br><span class="line">NOP .. //EXE</span><br><span class="line">NOP .. //ID</span><br><span class="line">LABEL:</span><br><span class="line">inst1 .. //IF</span><br><span class="line">inst2 ..</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>IF， ID阶段Stall不触发，IF阶段pc更新为跳转后的pc, 即PC_jump</strong></li>
</ul>
<p>然后按照新的pc顺序执行。</p>
<p><strong>也就是说，在数据冲突和控制冲突同时发生的时候，我们优先考虑控制冲突，即按照处理控制冲突的方式处理。</strong></p>
<h3 id="5-6-Bram-in-Regs"><a href="#5-6-Bram-in-Regs" class="headerlink" title="5-6 Bram in Regs"></a>5-6 Bram in Regs</h3><p>根据 3-1 SCPU to Pipeline中的通路图，Regs模块被ID， WB两个阶段被用到。如果要将其改写为Bram模块我们需要做如下操作：</p>
<p>将Regs模块中的取寄存器，写寄存器操作全改为时序电路，即只在时钟上升沿触发，代码改写如下：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="VERILOG"><figure class="iseeu highlight /verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> Regs (</span><br><span class="line">  <span class="keyword">input</span>         clk,</span><br><span class="line">  <span class="keyword">input</span>         rst,</span><br><span class="line">  <span class="keyword">input</span>         we,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">input</span>  [<span class="number">4</span>:<span class="number">0</span>]  read_addr_1,</span><br><span class="line">  <span class="keyword">input</span>  [<span class="number">4</span>:<span class="number">0</span>]  read_addr_2,</span><br><span class="line">  <span class="keyword">input</span>  [<span class="number">4</span>:<span class="number">0</span>]  write_addr,</span><br><span class="line">  <span class="keyword">input</span>  [<span class="number">63</span>:<span class="number">0</span>] write_data,</span><br><span class="line">  <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">63</span>:<span class="number">0</span>] read_data_1,</span><br><span class="line">  <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">63</span>:<span class="number">0</span>] read_data_2</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">integer</span> i;</span><br><span class="line">  (* ram_style = <span class="string">&quot;block&quot;</span> *)<span class="keyword">reg</span> [<span class="number">63</span>:<span class="number">0</span>] register [<span class="number">0</span>:<span class="number">31</span>]; <span class="comment">// x1 - x31, x0 keeps zero</span></span><br><span class="line">    <span class="comment">// 这里不太确定是不是ram_style....但应该是这么写没错叭。。。？</span></span><br><span class="line">  <span class="keyword">always</span>@(*)<span class="keyword">begin</span></span><br><span class="line">    register[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">      <span class="keyword">if</span> (!rst)  <span class="keyword">for</span> (i=<span class="number">0</span> ; i &lt; <span class="number">32</span> ; i = i + <span class="number">1</span>) register[i][<span class="number">63</span>:<span class="number">0</span>] &lt;= <span class="number">64&#x27;h00000000</span> ; <span class="comment">// reset</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (we == <span class="number">1</span>&amp;&amp;write_addr!=<span class="number">0</span>) <span class="keyword">begin</span></span><br><span class="line">        register[<span class="number">0</span>] &lt;= <span class="number">0</span>;</span><br><span class="line">        register[write_addr][<span class="number">63</span>:<span class="number">0</span>] &lt;= write_data[<span class="number">63</span>:<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">end</span> <span class="comment">// write register</span></span><br><span class="line">      read_data_1 &lt;=  register[read_addr_1]; <span class="comment">// 时序电路</span></span><br><span class="line">      read_data_2 &lt;=  register[read_addr_2];</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>同时，ID的取寄存器要提前一拍进行，即移到IF阶段。<strong>将需要读的寄存器地址在IF阶段就传给Regs模块，只需要改变Regs接口所传入的指令为inst_IF，而不是inst_ID，即可在下一拍通过read_data_1，read_data_2两条线自然传回ID，完成了寄存器数据的同步读取。</strong></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="VERILOG"><figure class="iseeu highlight /verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Regs register( <span class="comment">//Regs模块</span></span><br><span class="line">    <span class="variable">.clk</span>(clk),</span><br><span class="line">    <span class="variable">.rst</span>(rstn),</span><br><span class="line">    <span class="variable">.we</span>(reg_write),</span><br><span class="line">    <span class="variable">.read_addr_1</span>(inst_IF[<span class="number">19</span>:<span class="number">15</span>]), <span class="comment">// ID 改为inst_IF</span></span><br><span class="line">    <span class="variable">.read_addr_2</span>(inst_IF[<span class="number">24</span>:<span class="number">20</span>]), <span class="comment">// ID 改为inst_IF</span></span><br><span class="line">    <span class="variable">.write_addr</span>(inst_WB[<span class="number">11</span>:<span class="number">7</span>]), <span class="comment">// WB</span></span><br><span class="line">    <span class="variable">.write_data</span>(Ram_to_Path), <span class="comment">// WB</span></span><br><span class="line">    <span class="variable">.read_data_1</span>(read_data_1), <span class="comment">// ID</span></span><br><span class="line">    <span class="variable">.read_data_2</span>(read_data_2), <span class="comment">// ID</span></span><br><span class="line">    <span class="variable">.debug_reg</span>(debug_reg), <span class="comment">// ?</span></span><br><span class="line">    <span class="variable">.fin_reg</span>(fin_reg) <span class="comment">// ?</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<p>ID的接口连线如下：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="VERILOG"><figure class="iseeu highlight /verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ID ID1(</span><br><span class="line">    <span class="variable">.inst</span>(inst_ID),</span><br><span class="line">    <span class="comment">// .mask(mask),</span></span><br><span class="line">    <span class="variable">.pc</span>(pc_ID),</span><br><span class="line">    <span class="variable">.valid_ID</span>(valid_ID),</span><br><span class="line">    <span class="variable">.read_data_1</span>(read_data_1),</span><br><span class="line">    <span class="variable">.read_data_2</span>(read_data_2),</span><br><span class="line">    <span class="variable">.rs1_name</span>(rs1_ID),</span><br><span class="line">    <span class="variable">.rs2_name</span>(rs2_ID),</span><br><span class="line">    <span class="variable">.rs1</span>(rs1_data_ID),</span><br><span class="line">    <span class="variable">.rs2</span>(rs2_data_ID),</span><br><span class="line"></span><br><span class="line">    <span class="variable">.b</span>(b_ID), <span class="comment">//decoder</span></span><br><span class="line">    <span class="comment">// .pc_next(pc_in),</span></span><br><span class="line">    <span class="comment">// .br_taken(npc_sel_EXE),</span></span><br><span class="line"></span><br><span class="line">    <span class="variable">.alu_option</span>(alu_option_ID),</span><br><span class="line">    <span class="variable">.rs2_WB</span>(rs2_MEM_ID),</span><br><span class="line">    <span class="variable">.less</span>(less_ID)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<p>这样就完成了基本的Bram替换Dram，实现Regs模块。</p>
<p>但这么做可能会有一些问题比如：</p>
<ul>
<li><p><strong>速度和延迟</strong>：与传统的寄存器相比，BRAM的访问速度较慢，因为它位于存储层次结构的较低级别。这会引入延迟，可能导致指令执行的性能下降。特别是在需要频繁读写寄存器的情况下，<strong>BRAM的延迟可能成为瓶颈</strong>。</p>
</li>
<li><p><strong>容量限制</strong>：BRAM的容量相对有限，远远小于传统的寄存器文件。<strong>这意味着在使用BRAM实现寄存器组时，可能无法提供足够多的寄存器</strong>。如果设计需要大量的寄存器，BRAM的容量限制可能会成为问题。</p>
</li>
<li><p><strong>写冲突和竞争条件</strong>：当多个指令同时尝试写入同一个BRAM位置时，<strong>会发生写冲突和竞争条件</strong>。由于BRAM的写入操作是顺序执行的，这可能导致指令的顺序被打乱或数据被覆盖。需要适当的同步机制来处理这些冲突和竞争条件。</p>
</li>
<li><p><strong>接口和控制逻辑</strong>：使用BRAM作为寄存器组需要适当的接口和控制逻辑，以实现寄存器的读写操作。<strong>这涉及到将BRAM与处理器的指令集架构和总线系统进行适配，可能需要额外的复杂性和开发工作</strong>。</p>
</li>
</ul>
<p><strong>结论：辩证地来看，我们需要根据实际的硬件环境来决定是否要采用Bram来实现寄存器组。</strong></p>
<h3 id="5-7-关键路径"><a href="#5-7-关键路径" class="headerlink" title="5-7 关键路径"></a>5-7 关键路径</h3><p>打开vivado，综合，打开 Time summary</p>
<p><img src="/2023/11/22/Computer-System-II-Lab1-%EF%BC%9A%E5%9F%BA%E4%BA%8EStall%E7%9A%84%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF/17.png" alt="image-20231023235900520"></p>
<p>找到slack最短的Path，即Path1, 此路径即为Pipeline的关键路径。看到时延$Total Delay&#x3D;11.646$</p>
<blockquote>
<p>在计算机体系结构中，”slack”（松弛时间）是指指令流水线中的额外等待时间。它表示在特定情况下，由于冲突或其他原因，流水线中的某些阶段需要等待以便继续执行。</p>
<p>Slack的存在是由于指令流水线中的依赖关系和冲突。当一个指令需要等待之前的指令完成某个操作（如读取数据）时，就会产生松弛时间。这可能是由于数据冲突、控制冲突、结构冲突或资源冲突等原因引起的</p>
</blockquote>
<p>将该路径用电路图展示出来：</p>
<p><img src="/2023/11/22/Computer-System-II-Lab1-%EF%BC%9A%E5%9F%BA%E4%BA%8EStall%E7%9A%84%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF/18.png" alt="image-20231024000051687"></p>
<p>对该电路图进行分析：…….</p>
<p>好吧分析不了一点根本看不明白是啥，而且这好像不是一条从IF到WB的完整通路，而是中间的一段回路？</p>
<p>该Path从ID_EXE阶段间寄存器起始，将rs1的值传入ALU_result_MEM，接着生成br_taken。</p>
<p><img src="/2023/11/22/Computer-System-II-Lab1-%EF%BC%9A%E5%9F%BA%E4%BA%8EStall%E7%9A%84%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF/19.png" alt="image-20231024000110255"></p>
<p>之后br_taken有传给EXE。。。。（这信号不是从EXE传出去的么，and为什么ALU_result_MEM会传给EXE，，这玩应不也是EXE传出去的么。。。）</p>
<p><img src="/2023/11/22/Computer-System-II-Lab1-%EF%BC%9A%E5%9F%BA%E4%BA%8EStall%E7%9A%84%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF/20.png" alt="image-20231024000329090"></p>
<p>之后，，好像到了IF。。。？嗯。。好像把什么莫名其妙的东西传给了IF阶段的pc。。。</p>
<p><img src="/2023/11/22/Computer-System-II-Lab1-%EF%BC%9A%E5%9F%BA%E4%BA%8EStall%E7%9A%84%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF/21.png" alt="image-20231024000621927"></p>
<p>好的，不妨让我们大胆猜测一下这是<strong>Pipeline在EXE阶段处理一条跳转指令。</strong></p>
<ul>
<li><p><strong>EXE阶段产判断跳转指令的跳转条件，并生成br_taken信号</strong></p>
</li>
<li><p><strong>br_taken信号传递给Race_Control模块，生成IFID_Flush的信号传递给IFID阶段间寄存器插入bubble。</strong></p>
</li>
<li><p><strong>br_taken信号传递给Race_Control模块，生成IDEXE_Flush的信号传递给IDEXE阶段间寄存器插入bubble</strong></p>
</li>
<li><p><strong>br_taken信号指挥调度IF阶段的pc为跳转之后的pc，并在RAM模块处将下一条指令的地址设置为跳转之后指令的pc。</strong></p>
</li>
</ul>
<pre class="mermaid">graph LR;
EXE --> o(br_taken);
o --> L((RaceControl)) -.flush.->IFID;
L -.flush.-> IDEXE;
o --> IF -.-> pc_jump;
EXE --> ALU -.-> pc_jump;
o -.-> K((RAM)) -.-> inst_jump -.-> IF;</pre>

<p>嗯，感觉确实做了蛮多事情的。</p>

      
    </div>
    
      <footer class="article-footer">
        完
      </footer>
    
  </div>
  
    
    <link rel="stylesheet" href="/css/gitment.css"> 
<script src="/js/gitment.js"></script>

<div id="gitmentContainer"></div>

<script>
var gitment = new Gitment({
  owner: '',
  repo: '',
  oauth: {
    client_id: '',
    client_secret: '',
  },
})
gitment.render('gitmentContainer')
</script>

  
  
</article>
</section>
        <aside id="sidebar">
  
    <div class="widget-box">
  <div class="avatar-box">
    <img class="avatar" src="/images/default-avatar.jpg" title="图片来自网络"></img>
    <h3 class="avatar-name">
      
        晚栀
      
    </h3>
    <p class="avatar-slogan">
      且似尘间世与我，总相见，不相熟...
    </p>
  </div>
</div>


  
    

  
    

  
    
  
    
  <div class="widget-box">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">November 2023</a></li></ul>
    </div>
  </div>

  
    
  <div class="widget-box">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/11/22/Computer-System-II-Lab1-%EF%BC%9A%E5%9F%BA%E4%BA%8EStall%E7%9A%84%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF/">Computer System II Lab1 ：基于Stall的五级流水线</a>
          </li>
        
      </ul>
    </div>
  </div>

  
      <div class="widget-box">
    <h3 class="widget-title">友链</h3>
    <div class="widget">
      
        <a style="display: block;" href="/null" title target='_blank'
        >友链招租，v我50</a>
      
    </div>
  </div>

  
</aside>
      </div>
      <footer id="footer">
  <div class="foot-box global-width">
    &copy; 2023 John Doe &nbsp;&nbsp;
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    &nbsp;|&nbsp;主题 <a target="_blank" rel="noopener" href="https://github.com/yiluyanxia/hexo-theme-antiquity">antiquity</a>
    <br>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span id="busuanzi_container_site_pv">不蒜子告之   阁下是第<span id="busuanzi_value_site_pv"></span>个访客</span>
  </div>
</footer>
      <script src="https://code.jquery.com/jquery-2.0.3.min.js"></script>
<script>
if (!window.jQuery) {
var script = document.createElement('script');
script.src = "/js/jquery-2.0.3.min.js";
document.body.write(script);
}
</script>

  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




    </div>
    <nav id="mobile-nav" class="mobile-nav-box">
  <div class="mobile-nav-img mobile-nav-top"></div>
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/PWN" class="mobile-nav-link">Pwn</a>
  
  <div class="mobile-nav-img  mobile-nav-bottom"></div>
</nav>    
  </div>
</body>
</html>